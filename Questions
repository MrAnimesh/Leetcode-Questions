1. Remove Duplicates from sorted array
 
object Solution {

    def removeDuplicates(nums: Array[Int]): Int = {

        var n = nums.size

        if(n<=1) return n

        var j = 1

        for(i <- 1 until n){

            if(nums(i)!=nums(i-1)) {

               nums(j) = nums(i)

               j = j+ 1

            }

        }

        j

    }

}
 
2.Valid Palindrome

object Solution {

    def isPalindrome(s: String): Boolean = {

        // var str1 = s.filter(r => r.isLetter || r.isDigit).toLowerCase

        var i = 0;

        var j = s.size-1

         while(i < j){

             if(!(s(i).isDigit || s(i).isLetter)) i+=1;

             else if(!(s(j).isDigit || s(j).isLetter)) j-=1;

             else if (s(i).toLower != s(j).toLower) return false;

             else {

                 i+=1

                 j-=1

             }

         }

         return true;

    }

}
 
3. Conatiner with most water
 
object Solution {

    def maxArea(height: Array[Int]): Int = {

        var ans = 0 

        var i = 0;

        var j= height.size - 1;

        while(i < j){

            val len = j-i;

            val h = height(i).min(height(j));

            if(h * len > ans) ans = h*len

            if(height(i) < height(j)) i+=1;

            else j -=1;

        }

        return ans;

    }

}
 
4. Ransome note 

object Solution {

    def canConstruct(ransomNote: String, magazine: String): Boolean = {

         (ransomNote diff magazine).isEmpty

}

}
 
5. Climbing Stairs
 
object Solution {

    def climbStairs(n: Int): Int = {

        if(n<=2) return n

        var a = 1

        var b =2

        for(i <- 3 to n){

            var temp = b

            b = a+b

            a = temp

        }

        return b

    }

}
 
 
6. Pow(x,n)
 
object Solution {

    def myPow(x: Double, n: Int): Double = {

        var ans = 1.0

        var pow = n

        var num = x

        if(pow < 0) pow = -1 * pow

        while(pow > 0){

            if(pow %2 !=0){

                ans = ans *num

                pow = pow-1

            }

            else{

                num = num * num

                pow = pow/2

            }

        }

        if(n<0) ans = 1.0/ans

        ans

    }

}
 
 
 
7.Merge Sorted Array

object Solution {

    def merge(nums1: Array[Int], m: Int, nums2: Array[Int], n: Int): Unit = {

        var (left,right,finalindex) = (m-1,n-1,m+n-1)

        while(left>=0 && right>=0){

            if(nums2(right)>nums1(left)){

                nums1(finalindex) = nums2(right)

                finalindex-=1

                right -= 1

            }

            else{

                nums1(finalindex) = nums1(left);

                finalindex-=1

                left-=1

            }

        }

        while(left>=0) {

            nums1(finalindex) = nums1(left)

            finalindex-=1

            left-=1

        }

        while(right>=0) {

            nums1(finalindex) = nums2(right)

            finalindex-=1

            right-=1

            }

    }

}
 
8. Valid Anagram

approach 1

object Solution {

    def isAnagram(s: String, t: String): Boolean = 

    s.sorted == t.sorted

}
 
 
 
 
 
9. Reverse Words in a String 

object Solution {

    def reverseWords(s: String): String = {

        s.split(" ").reverse.filter(i => i!="").mkString(" ")

      // s.trim.split(" +").reverse.mkString(" ")

    }

}
 
10. Coin Change
 
object Solution {

   def coinChange(coins: Array[Int], amount: Int): Int = {

        val dp = Array.fill(13, 10001)(-1)

        def help(coin: Array[Int], amt: Int, ind: Int): Int = {

            if (amt == 0) 0

            else if (ind >= coin.length || amt < 0) 1e9.toInt

            else if (dp(ind)(amt) != -1) dp(ind)(amt)

            else {

                dp(ind)(amt) = math.min(help(coin, amt - coin(ind), ind) + 1, help(coin, amt, ind + 1))

                dp(ind)(amt)

            }

        }

        val a = help(coins, amount, 0)

        if (a >= 1e9.toInt) -1 else a

    }

}
 
11. Leap Year
 
object Solution{

  def isLeap():Boolean ={

       ((N%4==0 && N%100!=0) || N%400==0)

  }

}
 
 
 
 
 
12. 3 Sum
 
object Solution {

    def threeSum(nums: Array[Int]): List[List[Int]] = {

    var ans = List[List[Int]]()

    val arr = nums.sorted

    var i = 0 

     while(i < nums.length) {

        if (i != 0 && arr(i) == arr(i - 1)) {

            i+=1;

        }

        else{

        var j = i + 1

        var k = arr.length - 1

        while (j < k) {

            val sum = arr(i) + arr(j) + arr(k)

            if (sum < 0) j += 1

            else if (sum > 0) k -= 1

            else {

                ans = ans :+ List(arr(i), arr(j), arr(k))

                j += 1

                k -= 1

                while (j < k && arr(j) == arr(j - 1)) j += 1

                while (k > j && arr(k) == arr(k + 1)) k -= 1

            }

        }

        i+=1

        }

    }

    ans

    }

}
 
 
13. Search Insert Position

approach 

object Solution {

    def searchInsert(nums: Array[Int], target: Int): Int = {

          var lowerBoundIndex:Int = nums.indexWhere( _ >= target)

           if(lowerBoundIndex != -1) lowerBoundIndex else nums.size

    }

}
 
approach 1

def searchInsert(nums: Array[Int], target: Int): Int =

    if (nums contains target) nums.indexOf(target) 

    else nums.length - nums.dropWhile(target >= _).length
 
approach 2

def searchInsert_BinarySearch_tailrec(nums: Array[Int], target: Int): Int = {
 
    @tailrec

    def helper(start: Int, end: Int): Int = {
 
      if (start > end) return start

      val mid = start + (end - start) / 2
 
      nums(mid) match {

        case ele if ele == target => return mid

        case ele if target > ele => helper(mid + 1, end)

        case _ => helper(start, mid - 1)

      }

    }
 
    helper(0, nums.length - 1)

  }
 
 
 
14. Contains Duplicates
 
approach 1 

import scala.collection.mutable.HashSet

object Solution {

    def containsNearbyDuplicate(nums: Array[Int], k: Int): Boolean = {

       var left = 0 

       val window = HashSet[Int]()

       for(right <- nums.indices){

           if(right - left > k){

               window.remove(nums(left))

               left +=1

           }

           if(window.contains(nums(right)))

            return true

           window += nums(right)

       }

       false

    }

}
 
 
 
15. Maximum Depth of Binary Tree
 
@scala.annotation.tailrec
 
approach 1
 
object Solution {

    def maxDepth(root: TreeNode): Int = {

        if(root == null ) return 0

        var l = maxDepth(root.left)

        var r = maxDepth(root.right)

        return 1 + math.max(l,r)

    }

}
 
 
16. Min Path Sum

object Solution {

    def minPathSum(grid: Array[Array[Int]]): Int = {

      var row = grid.length

      var col = grid(0).length

      var arr = grid

      for(i <- 1 until col)

      arr(0)(i) += arr(0)(i - 1)

      for(i <- 1 until row)

      arr(i)(0) += arr(i - 1)(0)
 
      for(i <- 1 until row; j <- 1 until col)

      {

        arr(i)(j) += math.min(arr(i)(j-1), arr(i-1)(j))

      }

      return arr(row-1)(col-1)

    }

}
 
----------------------------------------------DAY 3 --------------------------------------------------------
 
17. Best Time to Buy and Sell Stock with Transaction Fee
 
object Stock_With_fee {

  def help(prices: Array[Int], index: Int, buy: Int, size: Int, fee: Int, memo: Array[Array[Int]]) :Int = {

    if (index == size) {

      return 0

    }

    else if (memo(index)(buy) != -1) {

      return memo(index)(buy)

    }
 
    var profit = 0

    if (buy == 0) // if buy ==0 then i can buy

        profit = math.max(help(prices, index + 1, 0, size, fee, memo), -prices(index) + help(prices, index + 1, 1, size, fee, memo))

    if (buy == 1)

        profit = math.max(help(prices, index + 1, 1, size, fee, memo), prices(index) - fee + help(prices, index + 1, 0, size, fee, memo))
 
    memo(index)(buy) = profit

    profit

  }
 
  def maxProfit(prices: Array[Int], fee: Int): Int = {

    var size = prices.length

    var memo = Array.fill(size, 2)(-1)

    if (size == 0)

      return 0

    var (index, buy) = (0, 0)

    var res = help(prices, index, buy, size, fee, memo)

    res

  }
 
  def main(args: Array[String]): Unit = {

    var prices:Array[Int] = Array(1,3,2,8,4,9)

    var fee = 2

    var res = maxProfit(prices,fee)

    print(res)

  }

}
 
18. Longest Substring without repeating character
 
object Solution {

    def lengthOfLongestSubstring(string: String): Int = {

        var memo : Map[Char,Int] = Map.empty

        var start,maxlength = 0

        for (end <- string.indices){

            if(memo contains string(end) ) {

                start = start max memo(string(end))+1

            }

            memo += (string(end)-> end)

            maxlength = maxlength max (end-start+1)

        }

        maxlength

    }

}
 
19.Group Anagrams

object Solution {

    def groupAnagrams(strs: Array[String]): List[List[String]] = {

        //  strs.toList.groupBy(_.sorted).values.toList

        strs.groupBy(e => e.sorted).map(e => e._2.toList).toList

    }

}
 
20. Valid Parenthesis
 
object Solution {

    def close(c: Char, p: Char): Boolean = {

        val s = c.toString + p.toString

        s == "()" || s == "{}" || s == "[]"

    }

    def isValid(s: String): Boolean = {

        val stk = scala.collection.mutable.Stack[Char]();

        for (i <- 0 until s.length) {

          if (s(i) == '(' || s(i) == '{' || s(i) == '[') {

                stk.push(s(i))

          } else {

                if (stk.isEmpty) return false

                if (!close(stk.top, s(i))) return false

                stk.pop()

          }

        }

        stk.isEmpty

    }

}
 
 
21. Average Level in a Binary Tree

import scala.collection.mutable._

object Solution {

    def averageOfLevels(root: TreeNode): Array[Double] = {

        if(root==null) Array[Double]();

        else{

            var ans:List[Double] = Nil;

            var q = Queue[TreeNode]();

            q.enqueue(root);

            while(q.size!=0){

                val size = q.size;

                var sum:Long = 0

                for(_ <- 0 until size){

                    val temp = q.dequeue()

                    sum += temp.value

                    if(temp.left!=null) q.enqueue(temp.left);

                    if(temp.right!=null) q.enqueue(temp.right);

                }

                ans = ans :+ (sum.toDouble/size.toDouble)

            }

            ans.toArray

        }

    }

}
 
22. Word Break
 
 
object Solution {
 
  def fillSet(s: scala.collection.mutable.Set[String], v: List[String]): Unit = {
 
    v.foreach(s += _)
 
  }

  def help(s: String, wordset: scala.collection.mutable.Set[String], start: Int, dp: Array[Int]): Int = {
 
    if (start == s.length) return 1
 
    if (dp(start) != -1) return dp(start)
 
    for (i <- start until s.length) {
 
      if (wordset.contains(s.substring(start, i + 1))) {
 
        if (help(s, wordset, i + 1, dp) == 1) return { dp(start) = 1; 1 }
 
      }
 
    }
 
    dp(start) = 0
 
    0
 
  }

  def wordBreak(s: String, wordDict: List[String]): Boolean = {
 
    val wordset = scala.collection.mutable.Set[String]()
 
    val dp = Array.fill(s.length)(-1)
 
    fillSet(wordset, wordDict)
 
    val a = help(s, wordset, 0, dp)
 
    a == 1
 
  }

}
 
 
1. Longest Consecutive Sequence
 
object Solution {

    def longestConsecutive(nums: Array[Int]): Int = {

    val s = nums.toSet

    var longest = 0
 
    for (element <- s) {

        if (!s.contains(element - 1)) {

            var j = 1

            while (s.contains(element + j)) {

                j += 1

            }

            longest = longest.max(j)

        }

    }
 
    longest

    }

}
 
2. Decode String

import scala.collection.mutable.Stack
 
object Solution {
 
def decodeString(s: String): String = {

    val st : Stack[Char] = Stack()

    var i = 0
 
    while (i < s.length) {

        if (s(i) != ']') {

            st.push(s(i))

        } else {

            var currStr = ""
 
            while (st.top != '[') {

                currStr = st.top + currStr

                st.pop()

            }
 
            st.pop() // for '['

            var number = ""
 
            // for calculating number

            while (st.nonEmpty && st.top.isDigit) {

                number = st.top + number

                st.pop()

            }
 
            val kTime = number.toInt // convert string to number
 
            for (_ <- 0 until kTime) {

                currStr.foreach(st.push)

            }

        }

        i += 1

    }
 
    var result = ""

    while (st.nonEmpty) {

        result = st.top + result

        st.pop()

    }
 
    result

}
 
}

3. Search in Rotated Sorted Array

approach 1.

object Solution {

   def search(nums: Array[Int], target: Int): Int = {

    var low = 0

    var high = nums.length - 1
 
    while (low <= high) {

        val mid = (low + high) / 2
 
        if (nums(mid) == target)

            return mid
 
        // If the first half of the array is sorted

        if (nums(low) <= nums(mid)) {

            if (nums(low) <= target && target < nums(mid))

                high = mid - 1

            else

                low = mid + 1

        }

        // If the second part is sorted

        else {

            if (nums(mid) < target && target <= nums(high))

                low = mid + 1

            else

                high = mid - 1

        }

    }
 
    -1

}
 
}
 
4. Flatten Nested List Iterator
 
approach 1
 
class NestedIterator(_nestedList: List[NestedInteger]) {

    var idx = -1;

    var data = Array[Int]();

    for(element <- _nestedList) {

        if(element.isInteger)

            data :+= element.getInteger

        else

            data ++= help(element.getList)

    }

    def help(data:Array[NestedInteger]):Array[Int] = {

        var ret = Array[Int]();

        for(element <- data) {

            if(element.isInteger)

                ret :+= element.getInteger;

            else

                ret ++= help(element.getList);

        }

        ret

    }

    def next(): Int = {

        idx += 1;

        data(idx);        

    }

    def hasNext(): Boolean = {

        idx + 1 != data.size

    }

}
 
 
 
 
5. House Robber

approach 1
 
object Solution {

    def rob(nums: Array[Int]): Int = {

        if(nums.size == 1) 

         return nums(0)

        if(nums.size ==2)

         return nums(0).max(nums(1))
 
        var memo = Array.fill(nums.size)(0)

        memo(0) = nums(0)

        memo(1) = nums(0).max(nums(1))

        for(i <- 2 until nums.size){

            memo(i) = math.max(memo(i-2)+nums(i),memo(i-1))

        }

        memo(nums.size-1)

    }

}
 
 
 
 
6. Clone Graph
 
approach 1

object Solution {

    def dfs(node: Node, copy: Node,vis : Array[Node]): Unit = {

    vis(copy.value) = copy

    for (adj <- node.neighbors) {

      if (vis(adj.value) == null) {

        val newnode = new Node(adj.value)

        copy.neighbors = newnode :: copy.neighbors

        dfs(adj, newnode,vis)

      } else {

        copy.neighbors = vis(adj.value) :: copy.neighbors

      }

    }

  }

    def cloneGraph(graph: Node): Node = {

       val vis = new Array[Node](101)

       if (graph == null) return null

       val copy = new Node(graph.value)

       dfs(graph, copy,vis)

       copy

    }

}
 
 
 
-------------------------------------- 7 FEB 2024 -------------------------------------------

7. Path Sum 

object Solution {

    def hasPathSum(root: TreeNode, targetSum: Int): Boolean = {

        if(root == null) return false

        if(root.value == targetSum && root.left==null && root.right==null) return true

        hasPathSum(root.left,targetSum-root.value)|| hasPathSum(root.right,targetSum-root.value)

    }

}
 
8. Number of Islands
 
object Solution {

    def numIslands(grid: Array[Array[Char]]): Int = {

        var count = 0

        for(row <- grid.indices){

            for(col <- grid.head.indices){

                if(grid(row)(col)=='1')

                 count +=1

                markAdj(grid,row,col)

            }

        }

        count

    }

    def markAdj(grid:Array[Array[Char]],row:Int,col:Int):Unit={

        if(row < 0 || row >=grid.length || col < 0 || col >= grid.head.length || grid(row)(col)!='1')

        { return  } 

        grid(row)(col)='2'  // mark it visited
 
       //mark  its all 4 adjacent 

       markAdj(grid,row,col-1)

       markAdj(grid,row,col+1)

       markAdj(grid,row-1,col)

       markAdj(grid,row+1,col)

    }

}
 
9. Triangle

object Solution {

    def minimumTotal(triangle: List[List[Int]]): Int = {

        val dp = Array.fill(201,201)(-1)

        def help(row: Int, col: Int, triangle: List[List[Int]]): Int = {

            if (row == triangle.size) return 0

            if (dp(row)(col) != -1) return dp(row)(col)

            val lowerLeft = triangle(row)(col) + help(row + 1, col, triangle)

            val lowerRight = triangle(row)(col) + help(row + 1, col + 1, triangle)

            dp(row)(col) = Math.min(lowerLeft, lowerRight)

            dp(row)(col)

        }

        help(0, 0, triangle)

    }

}
 
 
10. Min Stack

import scala.collection.mutable.Stack

class MinStack() {

    var stk1:Stack[Int] = Stack[Int]()

    var stk2: Stack[Int] = Stack[Int]()
 
    def push(x: Int) {

    if(stk2.isEmpty || x <= stk2.top) stk2.push(x)

    stk1.push(x)

    }
 
    def pop() {

     if(stk1.top == getMin) stk2.pop()

     stk1.pop()

    }
 
    def top(): Int = {

        stk1.top

    }
 
    def getMin(): Int = {

        stk2.top

    }
 
}
 
-

12.Find Minimum in Rotated Sorted Array
 
object Solution {

    def findMin(nums: Array[Int]): Int = {

        var left  = 0

        var right = nums.length -1

        while(left < right){

         var mid = (left + right)/2;

         if(nums(mid)< nums(right)) right = mid

         else left = mid+1

        }

        nums(left)

    }

}

13.Convert Sorted Array to Binary Search Tree
 
object Solution {

    def sortedArrayToBST(nums: Array[Int]): TreeNode = {

        help(nums,0,nums.length-1)

    }

    def help(nums:Array[Int],start:Int,end:Int):TreeNode = {

        if(start > end ) return null;

        val mid = (start+end)/2;

        new TreeNode(nums(mid),help(nums,start,mid-1),help(nums,mid+1,end))

    }

}

14. Symmetric Tree
 
object Solution {

    def help(root1: TreeNode, root2: TreeNode): Boolean = {

    if (root1 == null && root2 == null) true

    else if (root1 == null || root2 == null) false

    else if (root1.value == root2.value)

      help(root1.left, root2.right) && help(root1.right, root2.left)

    else false

  }

    def isSymmetric(root: TreeNode): Boolean = {

    if (root == null) true

    else help(root.left, root.right)

    }

}
 
